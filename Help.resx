<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>In the above 5x5 grid or matrix, twenty five integers, from 1 to 25, are filled in all cells to satisfy the rules below:

***Double Click a cell to erase the input***

- No duplicates.
- No holes (empty cells), i.e., no any integer is skipped or left unused.
- Cells are single-valued, i.e., no second integer is allowed in each cell.
- Integer 1 can begin in any randomly selected cell.
- Starting from 2, integers are filled in the order of 2 to 25.
- Every integer, except 1, must be placed in one of the empty cells surrounding its predecessor. Possible such cells include the predecessor's left, right, top, bottom, plus four corner cells. For instance, in the above example grid, when integer 1 is filled, it has 8 surrounding empty cells to select for next integer, 2. 
After 2 is filled in the upper-left cell of its predecessor 1, there are only 4 surrounding empty cells for integer 3. If integers are filled by following the above rules, the possible numbers of surrounding empty cells for any integer from 1 to 24 of this game should be in the range between 1 and 8, and zero for the ending integer 25.</value>
  </data>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>Different from Game 1, there are additional 24 empty edge cells displayed on each edge, including four corners of the center grid. For easy illustration, these edge cells are shown in blue and yellow in the above figure and already filled with a number. The goal of this game is similar to that of Game 1, user is going to fill all empty edge cells with integers from 2 to 24 using the following rules.

***Double Click a cell to erase the input***

- Like Game 1, each edge cell can be filled with only one integer between 2 and 24 with no duplicates and no skipping.
- For the ten top and bottom edge cells of the grid, they can only be filled in a number that appears in the corresponding columns. For example, 23 is filled in a top edge cell because 23 appears on the second column of the grid from the left. A similar rule then applies to the ten right and left side edge cells of the grid.
- To fill an integer in one of the four (yellow) corner edge cells, the number must exist on the corresponding longest diagonal of the grid. For example, 9 and 20 are filled in the upper-right and lower-left corner edge cells because they are on the northeast-to-southwest diagonal of the grid.
- Different from the filling rule of Game 1, the 24 integers are not necessarily filled in the edge cells in any particular order as long as they are all used to win the game. However, it will be easier (for the player or your program development) to simply fill them in ascending (2...24) or descending (24...2) order.
- Very similar to Game 1 about how a game could fail here. Either the numbers are filled in certain order or not, the game fails when one or more numbers can not get a cell to fill in. See the figure below for an example. Here numbers 2 ~ 22 are successfully get their places in the edge cells of the grid but 23 (and 24) apparently find no vacancy on its top, bottom, left, and right edge cells, and even 23 is one the northeast-to-southwest diagonal line, the two edge cells are already occupied by 9 and 20. In this case even 25 can still fill in the bottom cell, it doesn't help to win the game.</value>
  </data>
</root>